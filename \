#include "../HeaderFiles/maths.h"

Vector2 Vec2_Sub(Vector2 A, Vector2 B){
  
  return (Vector2){A.x - B.x, A.y - B.y};
}

Vector2 Vec2_Add(Vector2 A, Vector2 B){
  return (Vector2){A.x + B.x, A.y + B.y};
}

float Math_Pow2(float x){
  return x * x;
}

float Vec2_GetDistance(Vector2 A, Vector2 B){
  return sqrt(Math_Pow2(A.x - B.x) + Math_Pow2(A.y - B.y));
}

float Vec2_GetMagnitude(Vector2 A){
  return sqrt((Math_Pow2(A.x)) + (Math_Pow2(A.y)));
}

Vector2 Vec2_Normalize(Vector2 A){
  float mag = Vec2_GetMagnitude(A);
  if(mag == 0.0f){return (Vector2){0,0};}
  return (Vector2){A.x / mag, A.y / mag};
}

Vector2 Vec2_Scale(Vector2 A, float scale){ 
  return (Vector2){A.x * scale, A.y * scale};
}

float Math_Clamp(float val, float min, float max){
  if(val < min) return min;
  if(val > max) return max;
  return val;
}
Vector2 Vec2_Clamp(Vector2 target, Vector2 min, Vector2 max){

  Vector2 result = (Vector2){Math_Clamp(target.x, min.x, max.x),
  Math_Clamp(target.y, min.y, max.y)};

  return result;
}
float Vec2_Dot(Vector2 A, Vector2 B){
  return (A.x * B.x) + (A.y * B.y);
}
float Vec2_AngleCos(Vector2 A, Vector2 B){
  float dot = (A.x * B.x) + (A.y * B.y);
  return dot / (Vec2_GetMagnitude(A) * Vec2_GetMagnitude(B));
}

float Scalar_Projection(Vector2 A, Vector2 B){
  return Vec2_Dot(A, B) / Vec2_GetMagnitude(B);
}
Vector2 Vec2_Projection(Vector2 A, Vector2 B){
  float scale = (Vec2_Dot(A, B) / Vec2_Dot(B, B));
  return Vec2_Scale(B, scale);
}

float EaseInOutBack(float x){
  const float c1 = 1.70158;
  const float c2 = c1 * 1.525;

  return x < 0.5 
  ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2 
  : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;

}

float Det_3D(float m[3][3]){
   return  m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
         -m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
         +m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}

float Det_2D(float m[2][2]){
   return (m[0][0] * m[1][1]) - (m[1][0] * m[0][1]);
}


void Matrix_Rotate(float m[2][2], float angle){
  float cosA = cosf(angle);
  float sinA = sinf(angle);
  m[0][0] *= cosA;
  m[0][1] *= -sinA;
  m[1][0] *= sinA;
  m[1][1] *= cosA;
}
Vector2 Vec2_MatrixRotation(float rotationMatrix[2][2], Vector2 vector){
  return (Vector2){
    vector.x * rotationMatrix[0][0] + vector.y * rotationMatrix[0][1],
    vector.x * rotationMatrix[1][0] + vector.y * rotationMatrix[1][1]
  }; 
}
float Math_Orient2D(Vector2 A, Vector2 B, Vector2 C){

}
